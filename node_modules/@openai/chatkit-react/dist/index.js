// src/ChatKit.tsx
import * as React from "react";
import { jsx } from "react/jsx-runtime";
var ChatKit = React.forwardRef(
  function ChatKit2({ control, ...htmlProps }, forwardedRef) {
    const ref = React.useRef(null);
    React.useLayoutEffect(() => {
      const el = ref.current;
      if (!el) return;
      if (customElements.get("openai-chatkit")) {
        el.setOptions(control.options);
        return;
      }
      let active = true;
      customElements.whenDefined("openai-chatkit").then(() => {
        if (active) {
          el.setOptions(control.options);
        }
      });
      return () => {
        active = false;
      };
    }, [control.options]);
    return /* @__PURE__ */ jsx(
      "openai-chatkit",
      {
        ref: (chatKit) => {
          ref.current = chatKit;
          control.setInstance(chatKit);
          if (typeof forwardedRef === "function") {
            forwardedRef(chatKit);
          } else if (forwardedRef) {
            forwardedRef.current = chatKit;
          }
          if (!ref.current) {
            return;
          }
          const events = {
            "chatkit.error": "onError",
            "chatkit.response.end": "onResponseEnd",
            "chatkit.response.start": "onResponseStart",
            "chatkit.log": "onLog",
            "chatkit.thread.change": "onThreadChange",
            "chatkit.thread.load.start": "onThreadLoadStart",
            "chatkit.thread.load.end": "onThreadLoadEnd"
          };
          const eventNames = Object.keys(events);
          for (const event of eventNames) {
            ref.current.addEventListener(event, (e) => {
              const handler = control.handlers[events[event]];
              if (typeof handler === "function") {
                handler(e.detail);
              }
            });
          }
        },
        ...htmlProps
      }
    );
  }
);

// src/useChatKit.ts
import * as React3 from "react";

// src/useStableOptions.ts
import React2 from "react";
function isPlainObjectOrArray(obj) {
  return obj !== null && typeof obj === "object" && [null, Object.prototype].includes(Object.getPrototypeOf(obj)) || Array.isArray(obj);
}
function deepEqualIgnoringFns(a, b, seen = /* @__PURE__ */ new WeakMap()) {
  if (Object.is(a, b)) return true;
  if (typeof a === "function" && typeof b === "function") {
    return typeof a === typeof b;
  }
  if (!isPlainObjectOrArray(a) || !isPlainObjectOrArray(b)) {
    return false;
  }
  const mapped = seen.get(a);
  if (mapped && mapped === b) return true;
  seen.set(a, b);
  if (Array.isArray(a) || Array.isArray(b)) {
    if (!Array.isArray(a) || !Array.isArray(b) || a.length !== b.length)
      return false;
    for (let i = 0; i < a.length; i++) {
      if (!deepEqualIgnoringFns(a[i], b[i], seen)) return false;
    }
    return true;
  }
  const aKeys = Object.keys(a);
  const bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) return false;
  for (let i = 0; i < aKeys.length; i++) {
    const k = aKeys[i];
    if (!Object.prototype.hasOwnProperty.call(b, k)) return false;
    const av = a[k];
    const bv = b[k];
    if (!deepEqualIgnoringFns(av, bv, seen)) return false;
  }
  return true;
}
function withLatestFunctionWrappers(ref) {
  const path = [];
  const getByPath = (root, p) => p.reduce((acc, k) => acc == null ? acc : acc[k], root);
  const wrap = (parentPath, key) => {
    return (...args) => {
      const latestParent = getByPath(ref.current, parentPath);
      const latestFn = latestParent?.[key];
      if (typeof latestFn === "function") {
        return latestFn.apply(latestParent, args);
      }
    };
  };
  const visit = (v) => {
    if (typeof v === "function") {
      const key = path[path.length - 1];
      const parentPath = path.slice(0, -1);
      return wrap(parentPath, key);
    }
    if (Array.isArray(v)) {
      const base = path.length;
      const out = new Array(v.length);
      for (let i = 0; i < v.length; i++) {
        path[base] = i;
        out[i] = visit(v[i]);
      }
      path.length = base;
      return out;
    }
    if (v && typeof v === "object") {
      const base = path.length;
      const out = {};
      for (const k of Object.keys(v)) {
        path[base] = k;
        out[k] = visit(v[k]);
      }
      path.length = base;
      return out;
    }
    return v;
  };
  return visit(ref.current);
}
function useStableOptions(options) {
  const latestOptions = React2.useRef(options);
  latestOptions.current = options;
  const cache = React2.useRef(null);
  if (!cache.current || !deepEqualIgnoringFns(cache.current.snapshot, options)) {
    cache.current = {
      snapshot: options,
      shaped: withLatestFunctionWrappers(latestOptions)
    };
  }
  return cache.current.shaped;
}

// src/useChatKit.ts
var CHATKIT_METHOD_NAMES = Object.freeze([
  "focusComposer",
  "setThreadId",
  "sendUserMessage",
  "setComposerValue",
  "fetchUpdates",
  "sendCustomAction"
]);
function useChatKit(options) {
  const ref = React3.useRef(null);
  const stableOptions = useStableOptions(options);
  const methods = React3.useMemo(() => {
    return CHATKIT_METHOD_NAMES.reduce((acc, key) => {
      acc[key] = (...args) => {
        if (!ref.current) {
          console.warn("ChatKit element is not mounted");
          return;
        }
        return ref.current[key](...args);
      };
      return acc;
    }, {});
  }, []);
  const setInstance = React3.useCallback(
    (instance) => {
      ref.current = instance;
    },
    []
  );
  const control = React3.useMemo(() => {
    const options2 = {};
    const handlers = {};
    for (const [key, value] of Object.entries(stableOptions)) {
      if (/^on[A-Z]/.test(key) && key !== "onClientTool") {
        handlers[key] = value;
      } else {
        options2[key] = value;
      }
    }
    return {
      setInstance,
      options: options2,
      handlers
    };
  }, [stableOptions, setInstance]);
  return React3.useMemo(
    () => ({ ...methods, control, ref }),
    [methods, control]
  );
}
export {
  ChatKit,
  useChatKit
};
